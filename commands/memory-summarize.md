---
description: 总结会话内容，提取规范和知识到记忆系统
argument-hint: [可选: 补充说明]
allowed-tools: Read, Write, Edit, Bash, Glob
---

总结当前会话，提取用户纠正的内容、项目规范和领域知识，写入记忆系统。

**补充说明:** $ARGUMENTS

## 核心目标

回顾整个对话，找出两类信息:
1. **会话总结** — 做了什么、决策、学习 → 写入每日笔记
2. **规范提取** — 用户纠正的内容、告知的规范、项目知识 → 按实际代码项目分类写入

## 指令

### 第一步: 识别项目归属

**关键**: 规范必须写到实际的代码项目，不是工作区目录名。

判断方式:
- 检查当前目录是否包含 `projects/` 子目录
- 如果是（需求工作区），列出 `projects/` 下的实际代码项目
- 如果不是（普通项目），使用 `basename $PWD`

例: 在 `my-workspace/` 下工作:
- "不要用 Lombok" → 属于后端项目 `backend-api`
- "Vue 组件用 setup 语法" → 属于前端项目 `frontend-app`
- "XXL-Job 做定时任务" → 属于 `worker-service`

### 第二步: 扫描对话，提取用户纠正和规范

仔细回顾所有用户消息，识别以下类型的内容:

**A. 纠正 (用户说 "不要..."、"应该..."、"我们用的是...")**
- 例: "不要用 Lombok，我们项目禁止了" → 规范
- 例: "这个接口返回格式不对，应该是 {code, data, msg}" → API 规范
- 例: "数据库字段用下划线命名" → 命名规范

**B. 项目知识 (用户主动告知的技术细节)**
- 例: "我们用 MyBatis-Plus 不用 JPA" → 技术栈
- 例: "这个表有软删除字段 deleted" → 数据模型
- 例: "部署在阿里云 ECS 上" → 基础设施

**C. 开发习惯 (用户偏好的工作方式)**
- 例: "先改数据库再改代码" → 工作流程
- 例: "不需要写单元测试" → 测试策略
- 例: "提交信息用中文" → Git 规范

对每条提取的规范，判断它属于哪个实际代码项目。如果是通用的（跨项目适用），标记为通用。

### 第三步: 按项目分别写入 rules.md

对每个涉及的代码项目，写入对应的 rules.md:
- 路径: `~/.claude/memory/areas/projects/{实际代码项目名}/rules.md`
- 如果目录不存在，创建 `~/.claude/memory/areas/projects/{项目名}/` 目录
- 如果文件不存在，创建并初始化
- 如果文件已存在，读取后**合并去重**，不重复添加相同规则

格式:
```markdown
# {项目名} 开发规范

> 从开发会话中自动提取，由 /memory-summarize 维护

## 技术栈
- {框架、库、工具}

## 编码规范
- {命名、格式、模式}

## API 规范
- {接口格式、错误处理}

## 数据库规范
- {命名、模型约定}

## 禁止项
- {明确禁止的做法}

## 其他约定
- {不属于以上分类的规范}
```

注意:
- 每条规范一行，以 `- ` 开头
- 在规范后标注来源日期: `(2026-02-08)`
- 合并时检查是否已有相同或类似规则，避免重复
- 如果某个分类没有内容，省略该分类
- 通用规范（跨项目适用）写入 `~/.claude/memory/MEMORY.md` 的相应部分

### 第三步半: 提取数据库表知识

> **提示**: 如果需要批量提取表结构，可先运行自动化脚本（v2 统一模式）:
> ```bash
> python3 ~/.claude/scripts/extract-schema.py \
>   --db-host 127.0.0.1 --db-port 3306 \
>   --db-user root --db-password xxx --db-name my_database \
>   --sources /path/to/project-a,/path/to/project-b \
>   --source-labels project-a,project-b \
>   --project shared-db --dry-run
> ```
> 脚本从 MySQL INFORMATION_SCHEMA 获取表注释+列信息，结合代码中的 JOIN/DAO 数据，
> 按表名前缀分组，生成统一的 schema 文件到 `projects/shared-db/`。
> 以下手动提取流程适用于从对话上下文中补充业务语义（表职责、字段含义等）。

回顾对话中涉及的数据库表信息，按模块写入 schema 文件。

**信息来源（按优先级）:**

1. **代码分析**（最准确）: 对话中看到的 DAO 代码（@Select/@Insert 注解中的 SQL）、Entity 类、建表 SQL
2. **用户明确告知**: 用户纠正的表关系、告知的表职责
3. **对话上下文**: 讨论中涉及的表名和字段

**严禁**: 根据命名惯例推测表名或关系。只记录代码中看到的或用户明确说明的。

**如果本次对话涉及数据库表知识，执行以下步骤:**

**阶段 A: 整理并展示（不写入文件）**

1. 确定表所属模块:
   - 优先从代码包名判断: `com.xxx.customer` → `customer`
   - 其次从服务名判断: 用户说"这个是C端的表" → `c-customer`
   - 不确定时询问用户，或暂记为 `unclassified` 模块

2. 将提取到的表知识按以下格式输出给用户确认:

   ```
   ### 本次提取的数据库表知识

   **目标项目**: {项目名}

   **schema-index.md 变更:**
   | 模块 | 核心职责 | 表数量 | 关键表 |
   |------|----------|--------|--------|
   | {模块} | {职责} | {数量} | {表名} |  ← 新增/更新

   **schema/{模块}.md 变更:**

   新增表:
   - {表名} — {职责}

   新增关系:
   - {表A} 1──N {表B} ({关联字段})

   新增/更新表详情:
   - {表名}: 关键字段 {xxx}, 逻辑删除 {xxx}, ...
   ```

3. **等待用户确认**。用户可能:
   - 确认无误 → 进入阶段 B 写入
   - 指出错误 → 修正后重新展示
   - 要求跳过 → 不写入 schema 文件

**阶段 B: 用户确认后写入文件**

1. 更新 `schema-index.md`:
   - 路径: `~/.claude/memory/areas/projects/{实际代码项目名}/schema-index.md`
   - 如不存在，创建并初始化:
     ```markdown
     # {项目名} 数据库模块索引

     > 从开发会话中自动提取，由 /memory-summarize 维护
     > 最后更新: YYYY-MM-DD

     | 模块 | 核心职责 | 表数量 | 关键表 |
     |------|----------|--------|--------|
     ```
   - 如已存在，更新对应模块行（表数量、关键表列只保留 2~3 张核心表名）
   - 新模块追加行，保持按模块名排序
   - 更新 `最后更新` 日期

2. 更新 `schema/{模块}.md`:
   - 路径: `~/.claude/memory/areas/projects/{实际代码项目名}/schema/{模块}.md`
   - 如目录或文件不存在，创建并初始化:
     ```markdown
     # {模块名} 模块

     > 最后更新: YYYY-MM-DD

     ## 表清单

     | 表名 | 职责 | 分表 |
     |------|------|------|

     ## 表关系

     ## 核心表详情
     ```
   - 合并规则:
     - **表清单**: 表名去重，已有表更新职责/分表信息
     - **表关系**: 用 `表A 1──N 表B (关联字段)` 格式，跨模块标注 `[跨模块 → 模块名]`
     - **核心表详情**: 只记录开发中实际接触过的表（关键字段、逻辑删除、分表规则、备注）
     - 已有信息只补充不覆盖，不删除已有内容
   - 更新 `最后更新` 日期

**如果本次对话不涉及数据库表知识，跳过此步。**

### 第四步: 更新项目 facts.json

将关键的项目知识写入对应项目的原子事实:
- 路径: `~/.claude/memory/areas/projects/{实际代码项目名}/facts.json`
- 每条规范对应一个 fact，category 为 "convention"
- 递增 id

### 第五步: 写入每日笔记

在 `~/.claude/memory/daily/YYYY-MM-DD.md` 末尾追加:

```markdown
## HH:MM - {工作区或项目名} [总结]
- **任务**: {完成了什么}
- **决策**: {关键技术决策}
- **学习**: {新发现/经验}
- **提取规范**: {各项目分别提取的条数}
```

### 第六步: 输出确认

显示:
1. 写入的会话总结
2. 按项目分组显示提取的规范列表
3. 如果有避坑经验，提示使用 `/memory-avoid`

## 用法

```
/memory-summarize
/memory-summarize 重点关注数据库相关的约定
```
